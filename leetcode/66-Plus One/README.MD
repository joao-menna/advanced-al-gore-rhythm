## üî¢ Problema: Plus One

### **Autor:** Henrique | **Revisado por:** 

Voc√™ recebe um n√∫mero inteiro grande representado como um array de d√≠gitos `digits`, onde cada `digits[i]` √© o i-√©simo d√≠gito do inteiro. Os d√≠gitos s√£o ordenados do mais significativo para o menos significativo, da esquerda para a direita. O n√∫mero n√£o cont√©m zeros √† esquerda.

O objetivo √© incrementar o n√∫mero em uma unidade e retornar o array resultante.



---

### **Exemplos**

* **Exemplo 1:**
    * **Entrada:** `digits = [1, 2, 3]`
    * **Sa√≠da:** `[1, 2, 4]`
    * **Explica√ß√£o:** 123 + 1 = 124.
* **Exemplo 2:**
    * **Entrada:** `digits = [4, 3, 2, 1]`
    * **Sa√≠da:** `[4, 3, 2, 2]`
    * **Explica√ß√£o:** 4321 + 1 = 4322.
* **Exemplo 3:**
    * **Entrada:** `digits = [9]`
    * **Sa√≠da:** `[1, 0]`
    * **Explica√ß√£o:** 9 + 1 = 10.

---

### **Restri√ß√µes**

* `1 <= digits.length <= 100`
* `0 <= digits[i] <= 9`
* O array `digits` n√£o cont√©m zeros √† esquerda.

---

### **Como o LLM foi utilizado**

Neste problema, discuti com o LLM sobre as limita√ß√µes de tipos num√©ricos. Entendi que, como o array pode ter at√© 100 posi√ß√µes, converter o array para um `number` ou `BigInt` antes de somar poderia ser arriscado ou menos perform√°tico em certos ambientes. 

---
